// rorm-main exits after it created the `.models.json` file, so the main function is never executed
#![cfg_attr(
    feature = "rorm-main",
    allow(dead_code, unused_variables, unused_imports)
)]

use std::collections::HashMap;
use std::path::Path;

use axum::routing::get;
use axum::Router;
use rorm::cli::migrate::run_migrate_custom;
use rorm::config::DatabaseConfig;
use rorm::fields::types::Json;
use rorm::internal::field::Field;
use rorm::internal::field::FieldProxy;
use rorm::Database;
use rorm::DatabaseConfiguration;
use rorm::DatabaseDriver;
use rorm::Model;
use rorm::Patch;
use time::OffsetDateTime;
use tokio::net::TcpListener;
use tower_sessions::SessionManagerLayer;
use tower_sessions_rorm_store::RormStore;
use tower_sessions_rorm_store::SessionModel;
use tower_sessions_rorm_store::Value;

#[derive(Model)]
pub struct Session {
    /// The max-length of the primary key is set to 21 symbols as it is generated by nanoid
    #[rorm(primary_key, max_length = 255)]
    pub id: String,

    /// The point in time the session becomes invalid
    pub expires_at: OffsetDateTime,

    /// The session data
    pub data: Json<HashMap<String, Value>>,
}

impl SessionModel for Session {
    fn get_expires_at_field() -> FieldProxy<impl Field<Type = OffsetDateTime, Model = Self>, Self> {
        Self::F.expires_at
    }

    fn get_data_field(
    ) -> FieldProxy<impl Field<Type = Json<HashMap<String, Value>>, Model = Self>, Self> {
        Self::F.data
    }

    fn get_insert_patch(
        id: String,
        expires_at: OffsetDateTime,
        data: Json<HashMap<String, Value>>,
    ) -> impl Patch<Model = Self> + Send + Sync + 'static {
        Self {
            id,
            expires_at,
            data,
        }
    }

    fn get_session_data(&self) -> (String, OffsetDateTime, Json<HashMap<String, Value>>) {
        (self.id.clone(), self.expires_at, self.data.clone())
    }
}

async fn index(session: tower_sessions::Session) -> String {
    let counter: u64 = session.get("counter").await.unwrap().unwrap_or_default();
    session.insert("counter", counter + 1).await.unwrap();
    format!(
        "ID: {}, count: {:?}",
        session.id().unwrap_or_default(),
        session.get::<u64>("counter").await
    )
}

#[rorm::rorm_main]
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let db = initialize_db().await?;
    let router = Router::new()
        .route("/", get(index))
        .layer(SessionManagerLayer::new(RormStore::<Session>::new(db)));

    let listener = TcpListener::bind("127.0.0.1:3000").await?;
    println!("Start to listen on http://127.0.0.1:3000");
    axum::serve(listener, router).await?;

    Ok(())
}

async fn initialize_db() -> Result<Database, Box<dyn std::error::Error>> {
    let driver = DatabaseDriver::SQLite {
        filename: "test.sqlite3".to_string(),
    };

    // Apply migrations
    run_migrate_custom(
        DatabaseConfig {
            last_migration_table_name: None,
            driver: driver.clone(),
        },
        Path::new(file!())
            .parent()
            .ok_or("Invalid Path")?
            .parent()
            .ok_or("Invalid Path")?
            .join("migrations/")
            .to_str()
            .ok_or("Invalid string")?
            .to_string(),
        false,
        None,
    )
    .await?;

    // Connect to database
    Ok(Database::connect(DatabaseConfiguration::new(driver)).await?)
}
